---
title: "BIOST 561: Homework 4"
date: "Due date: 7:00pm on Monday, May 27th, 2024"
output: 
  bookdown::html_document2:
    number_sections: false
    toc: true
    toc_float:
      toc_collapsed: true
    theme: united
vignette: >
  %\VignetteIndexEntry{BIOST 561: Homework 4}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r setup, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
set.seed(10)
library(testthat)
library(UWBiost561)
library(igraph)
```

# Q1: Doing a code review of two other implementations

<u>**Question 1A**</u>: completed. 

<u>**Question 1B**</u>: Looking at two implementations you were given, summarize what you think the implementations are doing in one to four sentences each. (This is to practice reading other people's code.)

I was given implementation #1 and #6. 
Implementation #1 is an adaptation from the Bron-Kerbosch algorithm, which is a recursive algorithm to find all maximal cliques in a graph. If alpha=1, then Bron-Kerbosch algorithm is applied directly. If alpha<1, the algorithm is modified to not restrict the current node to be neighbors with the remaining nodes. The user can also choose to find the maximal partial clique using the "pivot" or "simple" method. For the pivot method, it will start iterating from the node with the maximum number of edges to other nodes. For the simple method... 

Implementation #6 iterates over each row of the matrix and checks which nodes it is connected to. If it is connected, it is then added into the cliques vector. Then the author updates the maximum density value depends on whether the clique the current row forms is bigger than the other cliques other rows form. 

<u>**Question 1C**</u>: For implementation #1, I hope the author can distinguish between the "pivot" and "simple" method more. When would be a time someone would want to use one over the other? The method should also default to either "simple" or "pivot". The author also kind of lost me at why we find the maximal cliques then have to extract the largest clique? Seems to me like the two parts can be combined? For implementation #6, there is a more abbreviated way to check conditions in the first few lines of the function. Otherwise, I think the author does a great job of providing comments in the code to explain what the code is doing. 

<u>**Question 1D**</u>: For implementation #6, it passed all the tests. For implementation 1, it passes the second test, but for the first, third, fourth, and fifth tests, the run time is too long (for both pivot and simple methods). I have commented out the first, fourth, and fifth tests due to run time issues. 

```{r, error = TRUE}
# test_that("compute_maximal_partial_clique works",{
#   set.seed(10)
#   simulation <- generate_partial_clique(
#     n = 30,
#     clique_fraction = 0.5,
#     clique_edge_density = 0.7
#   )
# 
#   adj_mat <- simulation$adj_mat
# 
#   res <- compute_maximal_partial_clique1(
#     adj_mat = adj_mat,
#     alpha = 0.7,
#     method="simple"
#   )
# 
#   expect_true(is.list(res))
#   expect_true(length(res$clique_idx)<=30)
#   expect_true(res$edge_density>=0.7)
# })

test_that("compute_maximal_partial_clique1 stops if given incorrect input",{
  set.seed(10)
  simulation <- cbind(c(1,0,2),c(0,1,0),c(2,0,1))
  simulation2 <- rep(c(1,0,1,0,1),50)

  expect_error(compute_maximal_partial_clique1(
    adj_mat = simulation,
    alpha = 0.7,
    method="simple"
  ))
  expect_error(compute_maximal_partial_clique1(
    adj_mat = simulation,
    alpha = 1.7,
    method="simple"
  ))
  expect_error(compute_maximal_partial_clique1(
    adj_mat = simulation2,
    alpha = 0.7,
    method="simple"
  ))
})

# test_that("compute_maximal_partial_clique1 takes less than 30 seconds to compute a 30 by 30 matrix",{
#   set.seed(10)
#   simulation <- generate_partial_clique(
#     n = 30,
#     clique_fraction = 0.5,
#     clique_edge_density = 0.7,
#     method="simple"
#   )
# 
#   adj_mat <- simulation$adj_mat
# 
#   start_time <- Sys.time()
#   res <- compute_maximal_partial_clique1(
#     adj_mat = adj_mat,
#     alpha = 0.7,
#     method="simple"
#   )
#   end_time <- Sys.time()
# 
#   expect_true(difftime(end_time, start_time, units = "secs") < 30)
# })

# test_that("compute_maximal_partial_clique1 work for matrices of all 1s",{
#   set.seed(10)
# 
#   simulation2 <- matrix(1, nrow = 30, ncol = 30)
# 
#   res2 <- compute_maximal_partial_clique1(
#     adj_mat = simulation2,
#     alpha = 0.7,
#     method="simple"
#   )
# 
#   expect_true(is.list(res2))
#   expect_true(length(res2$clique_idx)==30)
#   expect_true(res2$edge_density==1)
# })

# test_that("compute_maximal_partial_clique1 will find the maximal clique with edge
#           density greater than or equal to alpha",{
#   set.seed(10)
#   simulation <- generate_partial_clique(
#     n = 30,
#     clique_fraction = 0.5,
#     clique_edge_density = 0.7
#     )
#   simulation2 <- generate_partial_clique(
#     n =25,
#     clique_fraction = 0.5,
#     clique_edge_density = 0.5)
# 
#   alpha <- c(0.7,0.5)
#   res <- compute_maximal_partial_clique1(
#     adj_mat = simulation$adj_mat,
#     alpha = alpha[1],
#     method="simple"
#   )
#   res2 <- compute_maximal_partial_clique1(
#     adj_mat = simulation2$adj_mat,
#     alpha = alpha[2],
#     method="simple"
#   )
#   m <- c(length(res$clique_idx), length(res2$clique_idx))
# 
# 
#   expect_true((sum(simulation$adj_mat[res$clique_idx,res$clique_idx])-m[1])/2 >= alpha[1]*m[1]*(m[1]-1)/2)
#   expect_true((sum(simulation2$adj_mat[res2$clique_idx,res2$clique_idx])-m[2])/2 >= alpha[2]*m[2]*(m[2]-1)/2)
#   })
```

```{r}
testthat::test_that("compute_maximal_partial_clique6 works",{
  set.seed(10)
  simulation <- generate_partial_clique(
    n = 30,
    clique_fraction = 0.5,
    clique_edge_density = 0.7
  )

  adj_mat <- simulation$adj_mat

  res <- compute_maximal_partial_clique6(
    adj_mat = adj_mat,
    alpha = 0.7
  )

  expect_true(is.list(res))
  expect_true(length(res$clique_idx)<=30)
  expect_true(res$edge_density>=0.7)
})

test_that("compute_maximal_partial_clique6 stops if given incorrect input",{
  set.seed(10)
  simulation <- cbind(c(1,0,2),c(0,1,0),c(2,0,1))
  simulation2 <- rep(c(1,0,1,0,1),50)

  expect_error(compute_maximal_partial_clique6(
    adj_mat = simulation,
    alpha = 0.7
  ))
  expect_error(compute_maximal_partial_clique61(
    adj_mat = simulation,
    alpha = 1.7
  ))
  expect_error(compute_maximal_partial_clique61(
    adj_mat = simulation2,
    alpha = 0.7
  ))
})

test_that("compute_maximal_partial_clique6 takes less than 30 seconds to compute a 30 by 30 matrix",{
  set.seed(10)
  simulation <- generate_partial_clique(
    n = 30,
    clique_fraction = 0.5,
    clique_edge_density = 0.7
  )

  adj_mat <- simulation$adj_mat

  start_time <- Sys.time()
  res <- compute_maximal_partial_clique6(
    adj_mat = adj_mat,
    alpha = 0.7
  )
  end_time <- Sys.time()

  expect_true(difftime(end_time, start_time, units = "secs") < 30)
})

test_that("compute_maximal_partial_clique6 work for matrices of all 1s",{
  set.seed(10)

  simulation2 <- matrix(1, nrow = 30, ncol = 30)

  res2 <- compute_maximal_partial_clique6(
    adj_mat = simulation2,
    alpha = 0.7
  )

  expect_true(is.list(res2))
  expect_true(length(res2$clique_idx)==30)
  expect_true(res2$edge_density==1)
})

test_that("compute_maximal_partial_clique6 will find the maximal clique with edge
          density greater than or equal to alpha",{
  set.seed(10)
  simulation <- generate_partial_clique(
    n = 30,
    clique_fraction = 0.5,
    clique_edge_density = 0.7
    )
  simulation2 <- generate_partial_clique(
    n =25,
    clique_fraction = 0.5,
    clique_edge_density = 0.5)

  alpha <- c(0.7,0.5)
  res <- compute_maximal_partial_clique6(
    adj_mat = simulation$adj_mat,
    alpha = alpha[1]
  )
  res2 <- compute_maximal_partial_clique6(
    adj_mat = simulation2$adj_mat,
    alpha = alpha[2]
  )
  m <- c(length(res$clique_idx), length(res2$clique_idx))


  expect_true((sum(simulation$adj_mat[res$clique_idx,res$clique_idx])-m[1])/2 >= alpha[1]*m[1]*(m[1]-1)/2)
  expect_true((sum(simulation2$adj_mat[res2$clique_idx,res2$clique_idx])-m[2])/2 >= alpha[2]*m[2]*(m[2]-1)/2)
  })
```



# Q2: Constructing a simulation study

<mark>**Intent**: The intent of this question is to construct a simulation study that you'll run on Bayes.</mark>

In this question, you'll be designing a simulation. You will be doing this on Bayes for a couple of reasons: 1) To give you experience running code on Bayes, and 2) because your simulations might take a couple of hours to run.

Note: inside the file `compute_maximal_partial_clique_master.R` (which should now be in your `R` folder), I've provided you two functions: `compute_maximal_partial_clique_master()` and `compute_correct_density()`. You will find both functions useful for Q2 and Q3.

<u>**Question 2A**</u>: If I change n to 50 and time to 7, result 1 is all NA since it terminated prematurely, implementation 11 without the time limit will take too long to run. 

```{r}
library(UWBiost561)
set.seed(10)
data <- UWBiost561::generate_partial_clique(n = 10, 
                                            clique_fraction = 0.5,
                                            clique_edge_density = 0.95)

set.seed(10)
result1 <- UWBiost561::compute_maximal_partial_clique_master(
  adj_mat = data$adj_mat, 
  alpha = 0.95, 
  number = 11, 
  time_limit = 30
)
result1

set.seed(10)
result2 <- UWBiost561::compute_maximal_partial_clique11(
  adj_mat = data$adj_mat,
  alpha = 0.95
)
result2
```

<u>**Question 2B**</u>: 

I am hoping to test the functions' abilities to test for the maximal partial clique in a graph with a high clique fraction and low edge density. I plan to generate a graph with n=10, clique_fraction = 0.8, and clique_edge_density= 0.1 and 0.2 (for the different levels). I will be implementing all 25 methods in my simulation study. I'm hoping to see how the methods perform when we try to find a clique with low density. I am intending to run 2 trials per level. The maximum time I estimate for my simulation study 2x2x25x30 = 3000 seconds. 

<span style="color: blue;">(This is a writing question, not a coding question.)</span>

<u>**Question 2C**</u>: 

<span style="color: blue;">(There is nothing to report for this question. Your code will be in the `R` folder, **not**
in this R Markdown file.)</span>

<u>**Question 2D**</u>: 

<span style="color: blue;">(There is nothing to report for this question. Your code will be in the `tests/testthat` folder, **not**
in this R Markdown file.)</span>

<u>**Question 2E**</u>: 

```{r}
knitr::include_graphics("Screenshot3.png")
knitr::include_graphics("Screenshot4.png")
```

# Q3: Performing the simulation study

<u>**Question 3A**</u>: 

<span style="color: blue;">(There is nothing to report for this question. Your code will be in the `vignettes` folder, **not**
in this R Markdown file.)</span>

<u>**Question 3B**</u>: 

<span style="color: blue;">(There is nothing to report for this question.)</span>

<u>**Question 3C**</u>: 

<span style="color: blue;">(There is nothing to report for this question. You are simply running your `HW4_simulation_execute.slurm` file.)</span>

<u>**Question 3D**</u>: Finally, create a file called `HW4_simulation_plot.R` under the `vignettes` folder. You will design this script to load your saved results in `HW4_simulation.RData`, visualize the results, and save the plot into your `vignettes` folder. Name this one plot as `HW4_simulation.png`. (You can save your plot in a different file format, but `.png` is the easiest one to work with.)

How complicated should this script be? It depends on the results you saved in `HW4_simulation.RData`. For example, if you saved the clique size of each method in each trial for each level, then you might need to compute the average clique size across all the trials for each level in this script. 

What should you plot? It depends on what your simulation plan was intended to study (which you wrote in Question 2B). I'm leaving this open-ended so you can practice determining how best to demonstrate the results you're trying to study. 

Note 1: You can run your `HW4_simulation_plot.R` script <u>**interactively**</u> on Bayes. You do not need to write a `.slurm` script for this if you prefer not to (since your entire `HW4_simulation_plot.R` script should take only a few minutes to run. After all, you're simply loading in and plotting the results. There shouldn't be any very fancy computation being performed in this script, and indeed, you shouldn't be computing any maximal partial cliques in this script).

Note 2: Feel free to consult [https://r-graph-gallery.com/](https://r-graph-gallery.com/) to get ideas on how to meaningfully visualize your results.

<span style="color: blue;">(There is nothing to report for this question. Your code will be in the `vignettes` folder, **not**
in this R Markdown file.)</span>

<u>**Question 3E**</u>: Now, on Bayes, there should be at least four new files in the `vignettes` folder due to Question 3A-3D: `HW4_simulation_execute.R`, `HW4_simulation_execute.slurm`, `HW4_simulation_plot.R`, and `HW4_simulation.png`. (There might be many other files, but I am okay with it if there are more files than needed.) Commit and push all these files via Git (using the command line on Bayes) onto GitHub.com (via `git push`), and then pull all these files via Git onto your local laptop. (You can pull either through the command line via `git pull` or the RStudio GUI.)

Finally, include your plot in this R Markdown file. (I'm having you put your plot in your `vignettes` folder and push/pull your `UWBiost561` package because I'm assuming you knit this `HW4.Rmd` file locally on your laptop, but you need to somehow get your plot from Bayes onto your local laptop.)

# Q4: Describing your final project

<mark>**Intent**: The intent of this question is to make sure you have a plan for the final project.</mark>

I will release the final project specifications (again, which involve making a PkgDown website of any R package of your choosing of any scope) on Canvas. This will be released (at the latest) by May 19th.

Please write (in one to five sentences) what you are thinking of doing for your final project. If your answer hasn't changed since HW3, you can copy-paste your answer from HW3 into this question for HW4.

# Q5: Feedback (Optional)

This "question" is an additional way for students to communicate with instructors. 
You could include positive feedback about topics you enjoyed learning in this module, critiques about 
the course difficulty/pacing, 
or some questions/confusions you had about course material.
Your feedback can help shape the course for the rest of this quarter and 
future years. Please be mindful and polite when providing feedback.
You may leave this question blank.


